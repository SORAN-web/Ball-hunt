<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rolling Ball Runner - Ultra Advanced</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
    body, html {
      width: 100%; height: 100%; overflow: hidden;
      background: radial-gradient(ellipse at center, #001020 0%, #000000 100%);
      font-family: 'Orbitron', sans-serif;
      color: #0ff;
      display: flex; justify-content: center; align-items: center;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #gameContainer {
      position: relative;
      width: 900px;
      height: 500px;
      background: #000011;
      border-radius: 20px;
      box-shadow: 0 0 20px #0ff, inset 0 0 50px #003366;
    }
    canvas {
      display: block;
      width: 900px;
      height: 500px;
      border-radius: 20px;
      background: transparent;
    }
    #hud, #menu, #pauseScreen, #gameOverScreen {
      position: absolute;
      width: 100%;
      text-align: center;
      z-index: 10;
      color: #0ff;
      text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
      user-select: none;
      pointer-events: none;
      font-weight: 900;
    }
    #hud {
      top: 20px;
      font-size: 20px;
      font-weight: 700;
      display: flex;
      justify-content: space-around;
      pointer-events: auto;
      user-select: none;
      z-index: 20;
    }
    #menu, #pauseScreen, #gameOverScreen {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 30, 60, 0.9);
      padding: 30px 40px;
      border-radius: 15px;
      pointer-events: auto;
      font-size: 22px;
      line-height: 1.2;
      max-width: 80%;
      box-shadow: 0 0 20px #0ff, inset 0 0 60px #00ffff;
    }
    #menu h1, #pauseScreen h2, #gameOverScreen h2 {
      font-size: 42px;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }
    #menu p, #pauseScreen p, #gameOverScreen p {
      margin-bottom: 25px;
      font-weight: 700;
    }
    button {
      background: linear-gradient(90deg, #00ffff 0%, #004466 100%);
      border: none;
      border-radius: 12px;
      padding: 14px 30px;
      color: #001f26;
      font-weight: 900;
      font-size: 20px;
      cursor: pointer;
      transition: 0.3s ease;
      user-select: none;
      box-shadow: 0 0 10px #00ffff;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    button:hover {
      background: linear-gradient(90deg, #00ffff 0%, #00ffff 70%, #004466 100%);
      color: #e0ffff;
      box-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff;
    }
    button:active { transform: scale(0.95); }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="900" height="500"></canvas>
    <div id="hud" style="display:none;">
      <div>Score: <span id="score">0</span></div>
      <div>Lives: <span id="lives">3</span></div>
      <div>Multiplier: <span id="multiplier">1.0x</span></div>
    </div>
    <div id="menu">
      <h1>Rolling Ball Runner</h1>
      <p>Space / Tap to jump (Double jump). Avoid obstacles, survive!</p>
      <button id="startBtn">Start Game</button>
    </div>
    <div id="pauseScreen" style="display:none;">
      <h2>Paused</h2>
      <p>Press P or Tap to Resume</p>
    </div>
    <div id="gameOverScreen" style="display:none;">
      <h2>Game Over</h2>
      <p>Your Score: <span id="finalScore">0</span></p>
      <button id="restartBtn">Restart</button>
    </div>
  </div>
<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const hud = document.getElementById("hud");
  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const multiplierEl = document.getElementById("multiplier");
  const menu = document.getElementById("menu");
  const pauseScreen = document.getElementById("pauseScreen");
  const gameOverScreen = document.getElementById("gameOverScreen");
  const finalScoreEl = document.getElementById("finalScore");
  const startBtn = document.getElementById("startBtn");
  const restartBtn = document.getElementById("restartBtn");

  // Game constants
  const gravity = 1.1;
  const jumpStrength = -19;
  const baseSpeed = 7;
  const maxSpeed = 20;
  const groundBaseY = canvas.height - 110;
  const maxLives = 3;
  const worldWidth = 30000;

  // Parallax star layers for background
  const starLayers = [
    { count: 120, speedRatio: 0.2, stars: [] },
    { count: 80, speedRatio: 0.5, stars: [] },
    { count: 60, speedRatio: 0.8, stars: [] },
  ];

  function randRange(min, max) { return Math.random() * (max - min) + min; }

  // Initialize stars for each layer
  starLayers.forEach(layer => {
    for(let i=0; i<layer.count; i++){
      layer.stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: randRange(1,2.5),
        alpha: randRange(0.1,0.9),
      });
    }
  });

  // Sound effect placeholder
  function playSound(name) {
    // Example: playSound('jump'), playSound('collision'), playSound('powerup')
    // Insert your sound logic here if desired.
    // console.log("Sound:", name);
  }

  // Game state variables
  let ball, obstacles, powerUps, score, lives, scoreMultiplier, speed, gameRunning, paused, lastTime;
  let obstacleTimer, obstacleInterval;
  let cameraX = 0;

  // Ball class (moves forward visually)
  class Ball {
    constructor() {
      this.radius = 30;
      this.x = 200;
      this.y = groundBaseY - this.radius;
      this.vx = baseSpeed;
      this.vy = 0;
      this.jumpCount = 0;
      this.maxJumps = 2;
      this.grounded = true;
      this.shadowOffsetY = 0;
      this.shadowBaseAlpha = 0.3;
      this.shadowMaxAlpha = 0.8;
    }
    update() {
      this.x += this.vx * 0.12;
      if (this.x < 200) this.x = 200;
      if (this.x + this.radius > worldWidth) this.x = worldWidth - this.radius;
      this.vy += gravity;
      this.y += this.vy;
      const terrainY = getTerrainHeight(this.x);
      if (this.y + this.radius > terrainY) {
        this.y = terrainY - this.radius;
        this.vy = 0;
        if (!this.grounded) {
          this.grounded = true;
          this.jumpCount = 0;
        }
      } else {
        this.grounded = false;
      }
      this.shadowOffsetY = Math.min(30, Math.max(0, terrainY - (this.y + this.radius)));
    }
    jump() {
      if (this.jumpCount < this.maxJumps) {
        this.vy = jumpStrength;
        this.jumpCount++;
        this.grounded = false;
        createJumpParticles(this.x, this.y + this.radius);
        playSound('jump');
      }
    }
    draw() {
      const screenX = this.x - cameraX;
      const terrainY = getTerrainHeight(this.x);
      ctx.beginPath();
      ctx.ellipse(screenX, terrainY + this.shadowOffsetY, this.radius * 1.1, this.radius * 0.3, 0, 0, 2 * Math.PI);
      ctx.fillStyle = `rgba(0,0,0,${this.shadowBaseAlpha + (this.shadowMaxAlpha - this.shadowBaseAlpha) * (1 - this.shadowOffsetY / 30)})`;
      ctx.fill();

      const grad = ctx.createRadialGradient(screenX - this.radius/4, this.y - this.radius/3, this.radius/4, screenX, this.y, this.radius);
      grad.addColorStop(0, "#00ffff");
      grad.addColorStop(0.5, "#004080");
      grad.addColorStop(1, "#001122");
      ctx.fillStyle = grad;
      ctx.shadowColor = "#00ffff";
      ctx.shadowBlur = 16;
      ctx.beginPath();
      ctx.arc(screenX, this.y, this.radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  // Obstacle class
  class Obstacle {
    constructor(x, y, radius = 28) {
      this.x = x;
      this.y = y;
      this.radius = radius;
      this.color = "#660000";
      this.glowAlpha = 0.7;
      this.glowDirection = 1;
    }
    update() {
      this.x -= speed;
      this.glowAlpha += 0.015 * this.glowDirection;
      if (this.glowAlpha >= 1) this.glowDirection = -1;
      else if (this.glowAlpha <= 0.5) this.glowDirection = 1;
    }
    draw() {
      const screenX = this.x - cameraX;
      if(screenX + this.radius < 0 || screenX - this.radius > canvas.width) return;

      ctx.shadowColor = `rgba(255, 20, 20, ${this.glowAlpha})`;
      ctx.shadowBlur = 18;
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.arc(screenX, this.y, this.radius, 0, 2 * Math.PI);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.fillStyle = "#990000";
      ctx.arc(screenX, this.y, this.radius*0.7, 0, 2 * Math.PI);
      ctx.fill();
    }
  }

  // Power-up class
  class PowerUp {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.radius = 22;
      this.type = 'speed';
      this.collected = false;
      this.glow = 0;
    }
    update() {
      this.x -= speed;
      this.glow += 0.15;
    }
    draw() {
      const screenX = this.x - cameraX;
      if (screenX + this.radius < 0 || screenX - this.radius > canvas.width) return;
      ctx.save();
      ctx.shadowColor = "#0ff";
      ctx.shadowBlur = 20 + 10 * Math.sin(this.glow);
      ctx.beginPath();
      ctx.arc(screenX, this.y, this.radius, 0, 2 * Math.PI);
      ctx.fillStyle = "#00ffff";
      ctx.globalAlpha = 0.8 + 0.2 * Math.sin(this.glow);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      ctx.restore();
      ctx.beginPath();
      ctx.arc(screenX, this.y, this.radius * 0.6, 0, 2 * Math.PI);
      ctx.fillStyle = "#fff";
      ctx.fill();
    }
  }
  function spawnPowerUp() {
    const x = cameraX + canvas.width + Math.random() * 1000 + 600;
    const y = getTerrainHeight(x) - 60;
    powerUps.push(new PowerUp(x, y));
  }

  // Particle system for jumps & collisions
  const particles = [];
  class Particle {
    constructor(x, y, vx, vy, radius, color, lifetime=30) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.radius = radius;
      this.color = color;
      this.lifetime = lifetime;
      this.age = 0;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.vy += 0.3;
      this.age++;
      this.radius *= 0.95;
    }
    draw() {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.globalAlpha = Math.max(0, 1 - this.age / this.lifetime);
      ctx.arc(this.x - cameraX, this.y, this.radius, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
  function createJumpParticles(x, y) {
    for(let i=0; i<15; i++){
      const angle = Math.random() * Math.PI - Math.PI/2;
      const speed = Math.random() * 5 + 2;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      particles.push(new Particle(x + vx * 3, y, vx, vy, 6, "#00ffff", 40));
    }
  }
  function createCollisionParticles(x, y) {
    for(let i=0; i<25; i++){
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 6 + 2;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      particles.push(new Particle(x + vx * 3, y, vx, vy, 8, "#ff4444", 50));
    }
  }

  // Terrain function
  function getTerrainHeight(x) {
    return groundBaseY
      - 22 * Math.sin(x * 0.007 + 2)
      - 16 * Math.sin(x * 0.013 + 50)
      - 12 * Math.sin(x * 0.025 + 100);
  }

  function checkCollisionCircle(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    return dist < a.radius + b.radius;
  }

  function resetGame() {
    ball = new Ball();
    obstacles = [];
    powerUps = [];
    score = 0;
    lives = maxLives;
    scoreMultiplier = 1.0;
    speed = baseSpeed;
    gameRunning = true;
    paused = false;
    lastTime = 0;
    obstacleTimer = 0;
    obstacleInterval = 1400;
    cameraX = 0;

    hud.style.display = "flex";
    menu.style.display = "none";
    pauseScreen.style.display = "none";
    gameOverScreen.style.display = "none";

    requestAnimationFrame(gameLoop);
  }

  function gameOver() {
    gameRunning = false;
    hud.style.display = "none";
    gameOverScreen.style.display = "block";
    finalScoreEl.textContent = Math.floor(score);
  }

  function togglePause() {
    if (!gameRunning) return;
    paused = !paused;
    pauseScreen.style.display = paused ? "block" : "none";
    if (!paused) {
      lastTime = 0;
      requestAnimationFrame(gameLoop);
    }
  }

  function spawnObstacle() {
    const x = cameraX + canvas.width + Math.random() * 400 + 200;
    const y = getTerrainHeight(x) - 30;
    obstacles.push(new Obstacle(x, y));
  }

  function updateParticles() {
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.update();
      if(p.age > p.lifetime || p.radius < 0.3){
        particles.splice(i, 1);
      }
    }
  }
  function drawParticles() {
    particles.forEach(p => p.draw());
  }

  // Main game loop
  function gameLoop(timestamp=0) {
    if (!gameRunning || paused) return;

    if (!lastTime) lastTime = timestamp;
    const delta = timestamp - lastTime;
    lastTime = timestamp;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    speed += 0.003;
    if(speed > maxSpeed) speed = maxSpeed;

    // Ball & camera
    ball.update();
    cameraX += speed;

    // Power-up spawn
    if (Math.random() < 0.003) spawnPowerUp();

    // Obstacles
    obstacleTimer += delta;
    if(obstacleTimer > obstacleInterval){
      spawnObstacle();
      obstacleTimer = 0;
      if(obstacleInterval > 600) obstacleInterval -= 6;
    }

    // Parallax stars
    starLayers.forEach(layer => {
      layer.stars.forEach(star => {
        star.x -= speed * layer.speedRatio;
        if(star.x < 0) star.x += canvas.width;
        ctx.beginPath();
        ctx.fillStyle = `rgba(0, 255, 255, ${star.alpha})`;
        ctx.arc(star.x, star.y, star.size, 0, 2 * Math.PI);
        ctx.fill();
      });
    });

    // Terrain
    ctx.fillStyle = "#001d33";
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    for(let px=0; px<=canvas.width; px++){
      ctx.lineTo(px, getTerrainHeight(px + cameraX));
    }
    ctx.lineTo(canvas.width, canvas.height);
    ctx.closePath();
    ctx.fill();

    // Obstacles
    for(let i = obstacles.length - 1; i >= 0; i--){
      const ob = obstacles[i];
      ob.update();
      if(ob.x + ob.radius < cameraX){
        obstacles.splice(i, 1);
        score += 12 * scoreMultiplier;
      } else if(checkCollisionCircle(ball, ob)){
        createCollisionParticles(ball.x, ball.y);
        playSound('collision');
        lives--;
        obstacles.splice(i, 1);
        if(lives <= 0) {
          gameOver();
          return;
        }
      }
    }

    // Power-ups
    for (let i = powerUps.length - 1; i >= 0; i--) {
      const p = powerUps[i];
      p.update();
      if (p.x + p.radius < cameraX) {
        powerUps.splice(i, 1);
      } else if (checkCollisionCircle(ball, p)) {
        playSound('powerup');
        speed += 3;
        scoreMultiplier += 0.2;
        powerUps.splice(i, 1);
      }
    }

    updateParticles();

    // Draw
    ball.draw();
    obstacles.forEach(ob => ob.draw());
    powerUps.forEach(p => p.draw());
    drawParticles();

    // HUD UI Glow
    scoreEl.parentElement.style.textShadow = "0 0 12px #00ffff, 0 0 20px #00ffff";
    livesEl.parentElement.style.textShadow = "0 0 12px #ff4444, 0 0 20px #ff4444";
    multiplierEl.parentElement.style.textShadow = "0 0 12px #ffff00, 0 0 20px #ffff00";

    score += delta * 0.015 * scoreMultiplier;
    scoreEl.textContent = Math.floor(score);
    livesEl.textContent = lives;
    multiplierEl.textContent = scoreMultiplier.toFixed(1) + "x";

    if(ball.y - ball.radius > canvas.height + 100){
      gameOver();
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  // Input handlers
  function onJump() {
    if(!gameRunning || paused) return;
    ball.jump();
  }
  window.addEventListener("keydown", e => {
    if(e.code === "Space" || e.code === "ArrowUp"){
      e.preventDefault();
      onJump();
    }
    if(e.code === "KeyP"){
      togglePause();
    }
  });

  window.addEventListener("touchstart", e => {
    if(!gameRunning){
      resetGame();
    } else if(paused){
      togglePause();
    } else {
      onJump();
    }
  }, {passive:true});

  startBtn.onclick = () => resetGame();
  restartBtn.onclick = () => resetGame();

})();
</script>
</body>
</html>
